# 霍夫曼编码器

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Qt](https://img.shields.io/badge/Qt-6.0+-41CD52?logo=qt&logoColor=white)](https://www.qt.io/)
[![C++](https://img.shields.io/badge/C++-17-00599C?logo=cplusplus&logoColor=white)](https://isocpp.org/)

基于 Qt 开发的霍夫曼编码与解码工具，支持文本的编码、解码及校验功能。

## 截图预览

![程序截图](screenshot.png)

## 功能特性

- **文本输入**：支持输入或粘贴任意文本内容
- **频率统计**：自动统计每个字符的出现次数和频率
- **哈夫曼编码**：根据字符频率构建哈夫曼树，生成最优编码
- **文本编码**：将原始文本转换为二进制编码序列
- **文本解码**：将二进制序列还原为原始文本
- **校验功能**：对比原始文本与解码文本是否一致

## 技术栈

- **开发语言**：C++17
- **UI框架**：Qt 6
- **核心算法**：哈夫曼树（优先队列实现）

## 项目结构

```
huffman/
├── main.cpp           # 程序入口
├── mainwindow.h       # 主窗口头文件
├── mainwindow.cpp     # 主窗口实现
├── huffman.pro        # Qt项目文件
├── develop.md         # 开发文档
├── video_script.md    # 视频录制脚本
└── README.md          # 项目说明
```

## 编译运行

### 环境要求
- Qt 6.0 或更高版本
- 支持 C++17 的编译器

### 编译步骤
1. 使用 Qt Creator 打开 `huffman.pro`
2. 配置构建套件（Kit）
3. 点击构建并运行

## 使用说明

1. 在文本输入区输入需要编码的文本
2. 点击【统计频率】查看字符频率统计
3. 点击【生成编码】生成哈夫曼编码表
4. 点击【执行编解码】进行编码和解码
5. 点击【校验】验证解码结果是否正确
6. 点击【重置】清空所有内容

## 界面预览

```
┌──────────────────────────────────────────────────────┐
│                    霍夫曼编码器                        │
├─────────────────────────┬────────────────────────────┤
│  文本输入区              │  字符频率显示区             │
│                         │  字符 | 次数 | 频率         │
├─────────────────────────┼────────────────────────────┤
│  编码结果区              │  编码表显示区               │
│  (二进制序列)            │  字符 | 哈夫曼编码          │
├─────────────────────────┼────────────────────────────┤
│  解码结果区              │  [统计频率]                 │
│                         │  [生成编码]                 │
├─────────────────────────┤  [执行编解码]               │
│  校验区                  │  [校验]                    │
│                         │  [重置]                    │
└─────────────────────────┴────────────────────────────┘
```

## 算法说明

### 哈夫曼编码原理
1. 统计文本中每个字符的出现频率
2. 将所有字符作为叶子节点，频率作为权值
3. 使用最小堆构建哈夫曼树：每次取出两个最小权值节点合并
4. 从根到叶子的路径即为编码：左分支为0，右分支为1
5. 频率越高的字符，编码越短，从而实现数据压缩
